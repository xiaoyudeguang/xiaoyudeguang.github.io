<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>easy-swagger | 小雨的光的博客</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://xiaoyudeguang.github.io//favicon.ico?v=1582362369896">
<link rel="stylesheet" href="https://xiaoyudeguang.github.io//styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="为什么要选择easy-swagger？
        日常开发中，接口文档几乎是必不可少的一环，靠程序员自己维护接口文档 经常出现的几个问题是：需要额外花时间编写文档，从而导致更新不及时，维护又麻烦 。到最后，除非强制要求，否则接口文档几..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://xiaoyudeguang.github.io/">
        <img src="https://xiaoyudeguang.github.io//images/avatar.png?v=1582362369896" class="site-logo">
        <h1 class="site-title">小雨的光的博客</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      如果实在不知道该追求什么，那么保持每天都在进步就好了，你可以成功的！
    </div>
    <div class="site-footer">
      <a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=j768vrm3ur65vr3P-v6h7ODi" style="text-decoration:none;"><img src="http://rescdn.qqmail.com/zh_CN/htmledition/images/function/qm_open/ico_mailme_21.png"/></a> | <a class="rss" href="https://xiaoyudeguang.github.io//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">easy-swagger</h2>
            <div class="post-date">2020-02-20</div>
            
            <div class="post-content" v-pre>
              <p>为什么要选择easy-swagger？<br>
        日常开发中，接口文档几乎是必不可少的一环，靠程序员自己维护接口文档 经常出现的几个问题是：需要额外花时间编写文档，从而导致更新不及时，维护又麻烦 。到最后，除非强制要求，否则接口文档几乎不可用了。</p>
<p>基于注解生成接口文档的swagger一开始的确缓解了程序员和接口文档之间的矛盾，但是 过分的植入注解导致的注解泛滥又让很多人不得不放弃这种方式，开始转向读取注释的方式来生成文档。</p>
<p>然而基于注释的方式存在的问题是，如果程序员不及时更新注释又会导致接口文档不可用（比如参数变更）。而且打包之后注释就没了，强行将注释打包到jar的方式又会增加jar包的体积。</p>
<p>相信经历了这些的你一定希望出现一个对程序员和接口文档都友好的方式，这就是选择easy-swagger的理由。</p>
<p>介绍<br>
     easy-swagger的主要目标是解决前后端交互需要编写文档的困扰，服务对象是前端研发人员。如果你一直被写文档的恐惧支配，如果 你怀揣着减少编写文档工作的梦想，那么，请你收下这份礼物——easy-swagger。第一、简单易上手，配置简单，即插即用；第二、写代码时顺手写文档，不需要占用很大篇幅，简洁不啰嗦；第三、容易维护，只需要修改极少的东西就可以完成文档的更新；第四、就算你完全懒得在代码中加入 一个额外注解，它也能自动产出高可用的文档.；第五、超强悍的微服务文档聚合能力。</p>
<p>基础功能</p>
<ol>
<li>引用<br>
   新建maven项目引入easy-swagger依赖(点击 最新版本地址 查看最新版本)</li>
</ol>
<dependency>
    <groupId>io.github.xiaoyudeguang</groupId>
    <artifactId>easy-swagger</artifactId>
    <version>最新版本</version>
</dependency>
2. 编码
import com.zlyx.easycore.tool.Console;
import com.zlyx.easyswagger.annotations.SpringController;
import com.zlyx.easyswagger.annotations.SpringMapping;
<p>import io.swagger.annotations.ApiParam;</p>
<p>@SpringController(value = &quot;demoController&quot;, todo = { &quot;easy-swagger使用示例&quot; })<br>
public class DemoController {</p>
<pre><code>@SpringMapping(value = &quot;test&quot;, todo = { &quot;easy-swagger示例方法&quot; }, notes = &quot;随便写点啥，当做方法简介吧&quot;)
public Object test(String name, int age) {
	Console.log(name, age);
	return &quot;easy-swagger is an good tool!&quot;;
}
</code></pre>
<p>}<br>
3. 效果（打开浏览器访问：http://localhost:8080/docs.html）</p>
<ol start="4">
<li>修改默认配置<br>
import org.springframework.context.annotation.Bean;<br>
import org.springframework.context.annotation.Configuration;</li>
</ol>
<p>import com.zlyx.easyswagger.config.ApiConfiguration;</p>
<p>@Configuration<br>
public class SwaggerConfiguration {</p>
<pre><code>@Bean
public ApiConfiguration configApi() {
	return new ApiConfiguration()
			.setEnabled(true) //是否启用
			.setBasePath(&quot;/ttt&quot;) //设置请求路径前缀(可选配置)
			.setHost(&quot;http://localhost/8080&quot;) //配置域名(可选配置)
			.setShowPath(true) //文档中是否显示包路径
			.setLog(true) //是否显示切面日志
			.setVersion(&quot;1.1.0&quot;) //版本号
			.setUrl(&quot;https://gitee.com/xiaoyudeguang/easy-swagger&quot;) //项目托管地址
	;
}
</code></pre>
<p>}<br>
5.  自定义配置方式<br>
       如果easy-swagger配置Docket的方式无法满足你的需要，你可以在配置类中用自己习惯的方式添加Docket的Bean，像这样：</p>
<pre><code>@Bean
public Docket configDocket (){
	return new Docket(DocumentationType.SWAGGER_2).enable(false);
}
</code></pre>
<p>需要注意的事，这种方式配置Docket需要将enable属性设置为false，否则你将不能很好地使用easy-swagger。</p>
<p>说出来你可能不信，你已经成功的学会如何使用easy-swagger了。？？？没错，这就是全部使用步骤了。如果不是很有耐心往下看的话，你已经可以出师了。easy-swagger采用了大量自动配置的方案来优化使用体验。如果你想体验它的高级功能，那么，请接着往下看。</p>
<p>高级功能 <br>
1.  兼容原生swagger<br>
  为了适应大多数项目已经引入了swagger注解的情况，easy-swagger对swagger注解做了兼容。对于之前的代码你不需要做任何修改就可以同样体验到easy-swagger的能力。比如，下面的代码和上面示例中的代码具有一致的效果。</p>
<p>import org.springframework.web.bind.annotation.RequestMapping;<br>
import org.springframework.web.bind.annotation.RestController;</p>
<p>import com.zlyx.easycore.tool.Console;</p>
<p>import io.swagger.annotations.Api;<br>
import io.swagger.annotations.ApiOperation;</p>
<p>@Api(&quot;easy-swagger使用示例&quot;)<br>
@RestController<br>
@RequestMapping(&quot;demoController&quot;)<br>
public class DemoController {</p>
<pre><code>@ApiOperation(&quot;easy-swagger示例方法&quot;)
@RequestMapping(value = &quot;test&quot;)
public Object test(String name, String age) {
	Console.log(name, age);
	return &quot;easy-swagger is an good tool!&quot;;
}
</code></pre>
<p>}<br>
2. 分组功能<br>
   easy-swagger对swagger做了一层封装，你仍然可以使用swagger的分组功能。</p>
<p></p>
<p>编码示例</p>
<p>import org.springframework.context.annotation.Bean;<br>
import org.springframework.context.annotation.Configuration;</p>
<p>import com.zlyx.easyswagger.config.ApiConfiguration;</p>
<p>@Configuration<br>
public class SwaggerConfiguration {</p>
<pre><code>@Bean
public ApiConfiguration configApi() {
	return new ApiConfiguration()
		.addApiProperties(&quot;按包分组&quot;, &quot;按包分组&quot;, &quot;按包分组&quot;, &quot;com.zlyx.easytest.demo&quot;)
		.addApiProperties(&quot;按请求路径分组&quot;, &quot;按请求路径分组&quot;, &quot;按请求路径分组&quot;, &quot;com.zlyx.easytest&quot;, &quot;/demo/**&quot;)
		.addApiProperties(&quot;按包和请求路径分组&quot;, &quot;按包和请求路径分组&quot;, &quot;按包和请求路径分组&quot;, &quot;com.zlyx.easytest.demo&quot;, &quot;/demo/**&quot;);
}
</code></pre>
<p>}<br>
 效果展示</p>
<ol start="3">
<li>微服务聚合功能<br>
    相信微服务是目前大多数程序的选择。之前，如果需要聚合多个微服务程序的文档，微服务网关是必须的选择。作者也尝试过这种方式。但是，微服务网关的实现方式实在是让人痛苦不堪，一大堆的配置绕来绕去，我的天。我就是想看个文档，至于这么复杂么？</li>
</ol>
<p>对于easy-swagger来说，你不需要额外的工作就可以达到聚合文档的目的。具体步骤如下：</p>
<p>（1）假设本地已经启动了两个微服务程序（需要引入easy-swagger），端口分别是8081和8082。我们修改8080端口对应的服务的配置类：</p>
<p>import org.springframework.context.annotation.Bean;<br>
import org.springframework.context.annotation.Configuration;</p>
<p>import com.zlyx.easyswagger.config.ApiConfiguration;</p>
<p>@Configuration<br>
public class SwaggerConfiguration {</p>
<pre><code>@Bean
public ApiConfiguration configApi() {
	return new ApiConfiguration().addUrls(&quot;http://localhost:8081&quot;, &quot;http://localhost:8082&quot;);
}
</code></pre>
<p>}<br>
 通过上面代码，你已经把本地的8081和8082两个端口的微服务文档聚合进来了。打开8080端口的文档浏览器地址  你可以在右上角的下拉框里找到8081和8082两个端口的接口文档。</p>
<p>（2）通过（1）中的配置，8081和8082端口的接口文档已经聚合到了8080端口的微服务中，但是，这种方式只能聚合先于自己启动的微服务。所以，需要被聚合的微服务在自己启动时，主动去8080端口的服务注册自己。打开8081和8082端口对应的服务，修改配置：</p>
<p>package com.zlyx.easytest.config;</p>
<p>import org.springframework.context.annotation.Bean;<br>
import org.springframework.context.annotation.Configuration;</p>
<p>import com.zlyx.easyswagger.config.ApiConfiguration;</p>
<p>@Configuration<br>
public class SwaggerConfiguration {</p>
<pre><code>@Bean
public ApiConfiguration configApi() {
	return new ApiConfiguration().setManagerUrl(&quot;http://localhost:8080&quot;);
}
</code></pre>
<p>}<br>
有了这个配置，8081端口和8082端口的服务就会在自己启动时主动注册到8080端口的服务。</p>
<p>喜欢的话，到码云 https://gitee.com/xiaoyudeguang/easy-swagger 加个star呗</p>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://xiaoyudeguang.github.io/post/ge-chong-liu-lan-qi-du-shi-guo-yi-hou-wo-fei-chang-shen-chong-de-hui-gui-liao-360/">
                  <h3 class="post-title">
                    各种浏览器都试过以后，我非常慎重的回归了360...
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>





  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: '',
        owner: '',
        admin: [''],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
