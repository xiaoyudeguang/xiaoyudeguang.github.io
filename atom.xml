<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiaoyudeguang.github.io/</id>
    <title>赵光的博客</title>
    <updated>2020-03-08T10:38:20.847Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiaoyudeguang.github.io/"/>
    <link rel="self" href="https://xiaoyudeguang.github.io/atom.xml"/>
    <subtitle>如果实在不知道该追求什么，那么保持每天都在进步就好了，你可以成功的！</subtitle>
    <logo>https://xiaoyudeguang.github.io/images/avatar.png</logo>
    <icon>https://xiaoyudeguang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 赵光的博客</rights>
    <entry>
        <title type="html"><![CDATA[测试测试]]></title>
        <id>https://xiaoyudeguang.github.io/post/ce-shi-ce-shi/</id>
        <link href="https://xiaoyudeguang.github.io/post/ce-shi-ce-shi/">
        </link>
        <updated>2020-03-08T09:07:49.000Z</updated>
        <content type="html"><![CDATA[<pre><code>public class demo {
    public static void main(String[] args){
         System.out.println(&quot;测试);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[好用的软件]]></title>
        <id>https://xiaoyudeguang.github.io/post/hao-yong-de-ruan-jian/</id>
        <link href="https://xiaoyudeguang.github.io/post/hao-yong-de-ruan-jian/">
        </link>
        <updated>2020-03-08T08:33:40.000Z</updated>
        <content type="html"><![CDATA[<p>1.金山WPS移动版，安卓版WPS下载 （Android）：</p>
<p>​      http://mo.wps.cn/pc-app/Android/moffice_11.4.1_default_ProCn00110_multidex_c88969cc5ef.apk</p>
<p>​      激活秘钥： 694BF-YUDBG-EAR69-BPRGB-ATQXH</p>
<ol start="2">
<li>
<p>WPS Office 2019 v11.8.2.8576 专业增强版 / WPS 教育版（pc）：</p>
<p>https://www.qiyuzy.com/html/article/7.html</p>
</li>
<li>
<p>SoftDownloader 替代360/腾讯软件管家下载官方软件（pc：</p>
<p>https://www.qiyuzy.com/html/article/237.html</p>
</li>
<li>
<p>Adguard v7.2.2956 优秀的全局广告拦截工具绿色版（pc）：</p>
<p>https://www.qiyuzy.com/html/article/92.html</p>
</li>
<li>
<p>思维导图软件 MyDraw v4.2.0 绿色破解版本（pc）：</p>
<p>https://www.qiyuzy.com/html/article/466.html</p>
</li>
<li>
<p>百度网盘纯净版（pc）：</p>
<p>https://development5.baidupan.com/011516bb/2019/12/27/9d6fa4acb614eaba4c783d2312e8107a.7z?st=MfQels19-jTNCQ-Nw6K5lA&amp;e=1579080392&amp;b=BLFdxAW7VrZWuVGhCr0FvFSQXuUMllDOVCldZwF8&amp;fi=15681025&amp;up=</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[easy-swagger]]></title>
        <id>https://xiaoyudeguang.github.io/post/easy-swagger/</id>
        <link href="https://xiaoyudeguang.github.io/post/easy-swagger/">
        </link>
        <updated>2020-02-20T02:58:40.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="为什么要选择easy-swagger">为什么要选择easy-swagger？</h1>
<p>日常开发中，接口文档几乎是必不可少的一环，靠程序员自己维护接口文档 经常出现的几个问题是：需要额外花时间编写文档，从而导致更新不及时，维护又麻烦 。到最后，除非强制要求，否则接口文档几乎不可用了。</p>
<p>基于注解生成接口文档的swagger一开始的确缓解了程序员和接口文档之间的矛盾，但是 过分的植入注解导致的注解泛滥又让很多人不得不放弃这种方式，开始转向读取注释的方式来生成文档。</p>
<p>然而基于注释的方式存在的问题是，如果程序员不及时更新注释又会导致接口文档不可用（比如参数变更）。而且打包之后注释就没了，强行将注释打包到jar的方式又会增加jar包的体积。</p>
<p>相信经历了这些的你一定希望出现一个对程序员和接口文档都友好的方式，这就是选择easy-swagger的理由。</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="为什么要选择easy-swagger">为什么要选择easy-swagger？</h1>
<p>日常开发中，接口文档几乎是必不可少的一环，靠程序员自己维护接口文档 经常出现的几个问题是：需要额外花时间编写文档，从而导致更新不及时，维护又麻烦 。到最后，除非强制要求，否则接口文档几乎不可用了。</p>
<p>基于注解生成接口文档的swagger一开始的确缓解了程序员和接口文档之间的矛盾，但是 过分的植入注解导致的注解泛滥又让很多人不得不放弃这种方式，开始转向读取注释的方式来生成文档。</p>
<p>然而基于注释的方式存在的问题是，如果程序员不及时更新注释又会导致接口文档不可用（比如参数变更）。而且打包之后注释就没了，强行将注释打包到jar的方式又会增加jar包的体积。</p>
<p>相信经历了这些的你一定希望出现一个对程序员和接口文档都友好的方式，这就是选择easy-swagger的理由。</p>
<!-- more -->
<h1 id="介绍">介绍</h1>
<p>easy-swagger的主要目标是解决前后端交互需要编写文档的困扰，服务对象是前端研发人员。如果你一直被写文档的恐惧支配，如果 你怀揣着减少编写文档工作的梦想，那么，请你收下这份礼物——easy-swagger。第一、简单易上手，配置简单，即插即用；第二、写代码时顺手写文档，不需要占用很大篇幅，简洁不啰嗦；第三、容易维护，只需要修改极少的东西就可以完成文档的更新；第四、就算你完全懒得在代码中加入 一个额外注解，它也能自动产出高可用的文档.；第五、超强悍的微服务文档聚合能力。</p>
<h1 id="基础功能">基础功能</h1>
<h2 id="1-引用">1. 引用</h2>
<p>新建maven项目引入easy-swagger依赖(点击 最新版本地址 查看最新版本)</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;io.github.xiaoyudeguang&lt;/groupId&gt;
    &lt;artifactId&gt;easy-swagger&lt;/artifactId&gt;
    &lt;version&gt;最新版本&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="2-编码">2. 编码</h2>
<pre><code class="language-java">import com.zlyx.easycore.tool.Console;
import com.zlyx.easyswagger.annotations.SpringController;
import com.zlyx.easyswagger.annotations.SpringMapping;

import io.swagger.annotations.ApiParam;

@SpringController(value = &quot;demoController&quot;, todo = { &quot;easy-swagger使用示例&quot; })
public class DemoController {

	@SpringMapping(value = &quot;test&quot;, todo = { &quot;easy-swagger示例方法&quot; }, notes = &quot;随便写点啥，当做方法简介吧&quot;)
	public Object test(String name, int age) {
		Console.log(name, age);
		return &quot;easy-swagger is an good tool!&quot;;
	}

}
</code></pre>
<h2 id="3-效果打开浏览器访问httplocalhost8080docshtml">3. 效果（打开浏览器访问：http://localhost:8080/docs.html）</h2>
<h2 id="4-修改默认配置">4. 修改默认配置</h2>
<pre><code class="language-java">import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.zlyx.easyswagger.config.ApiConfiguration;

@Configuration
public class SwaggerConfiguration {

	@Bean
	public ApiConfiguration configApi() {
		return new ApiConfiguration()
				.setEnabled(true) //是否启用
				.setBasePath(&quot;/ttt&quot;) //设置请求路径前缀(可选配置)
				.setHost(&quot;http://localhost/8080&quot;) //配置域名(可选配置)
				.setShowPath(true) //文档中是否显示包路径
				.setLog(true) //是否显示切面日志
				.setVersion(&quot;1.1.0&quot;) //版本号
				.setUrl(&quot;https://gitee.com/xiaoyudeguang/easy-swagger&quot;) //项目托管地址
		;
	}

}
</code></pre>
<h2 id="5-自定义配置方式">5.  自定义配置方式</h2>
<p>如果easy-swagger配置Docket的方式无法满足你的需要，你可以在配置类中用自己习惯的方式添加Docket的Bean，像这样：</p>
<pre><code class="language-java">@Bean
public Docket configDocket (){
	return new Docket(DocumentationType.SWAGGER_2).enable(false);
}
</code></pre>
<p>需要注意的事，这种方式配置Docket需要将enable属性设置为false，否则你将不能很好地使用easy-swagger。</p>
<p>说出来你可能不信，你已经成功的学会如何使用easy-swagger了。？？？没错，这就是全部使用步骤了。如果不是很有耐心往下看的话，你已经可以出师了。easy-swagger采用了大量自动配置的方案来优化使用体验。如果你想体验它的高级功能，那么，请接着往下看。</p>
<h1 id="高级功能">高级功能</h1>
<h2 id="1-兼容原生swagger">1.  兼容原生swagger</h2>
<p>为了适应大多数项目已经引入了swagger注解的情况，easy-swagger对swagger注解做了兼容。对于之前的代码你不需要做任何修改就可以同样体验到easy-swagger的能力。比如，下面的代码和上面示例中的代码具有一致的效果。</p>
<pre><code class="language-java">import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.zlyx.easycore.tool.Console;

import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;

@Api(&quot;easy-swagger使用示例&quot;)
@RestController
@RequestMapping(&quot;demoController&quot;)
public class DemoController {

	@ApiOperation(&quot;easy-swagger示例方法&quot;)
	@RequestMapping(value = &quot;test&quot;)
	public Object test(String name, String age) {
		Console.log(name, age);
		return &quot;easy-swagger is an good tool!&quot;;
	}

}
</code></pre>
<h2 id="2-分组功能">2. 分组功能</h2>
<p>easy-swagger对swagger做了一层封装，你仍然可以使用swagger的分组功能。</p>
<p>编码示例</p>
<pre><code>import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.zlyx.easyswagger.config.ApiConfiguration;

@Configuration
public class SwaggerConfiguration {

	@Bean
	public ApiConfiguration configApi() {
		return new ApiConfiguration()
			.addApiProperties(&quot;按包分组&quot;, &quot;按包分组&quot;, &quot;按包分组&quot;, &quot;com.zlyx.easytest.demo&quot;)
			.addApiProperties(&quot;按请求路径分组&quot;, &quot;按请求路径分组&quot;, &quot;按请求路径分组&quot;, &quot;com.zlyx.easytest&quot;, &quot;/demo/**&quot;)
			.addApiProperties(&quot;按包和请求路径分组&quot;, &quot;按包和请求路径分组&quot;, &quot;按包和请求路径分组&quot;, &quot;com.zlyx.easytest.demo&quot;, &quot;/demo/**&quot;);
	}

}
</code></pre>
<p>效果展示</p>
<h2 id="3-微服务聚合功能">3. 微服务聚合功能</h2>
<p>相信微服务是目前大多数程序的选择。之前，如果需要聚合多个微服务程序的文档，微服务网关是必须的选择。作者也尝试过这种方式。但是，微服务网关的实现方式实在是让人痛苦不堪，一大堆的配置绕来绕去，我的天。我就是想看个文档，至于这么复杂么？</p>
<p>对于easy-swagger来说，你不需要额外的工作就可以达到聚合文档的目的。具体步骤如下：</p>
<p>（1）假设本地已经启动了两个微服务程序（需要引入easy-swagger），端口分别是8081和8082。我们修改8080端口对应的服务的配置类：</p>
<pre><code class="language-java">import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.zlyx.easyswagger.config.ApiConfiguration;

@Configuration
public class SwaggerConfiguration {

	@Bean
	public ApiConfiguration configApi() {
		return new ApiConfiguration().addUrls(&quot;http://localhost:8081&quot;, &quot;http://localhost:8082&quot;);
	}

}
</code></pre>
<p>通过上面代码，你已经把本地的8081和8082两个端口的微服务文档聚合进来了。打开8080端口的文档浏览器地址  你可以在右上角的下拉框里找到8081和8082两个端口的接口文档。</p>
<p>（2）通过（1）中的配置，8081和8082端口的接口文档已经聚合到了8080端口的微服务中，但是，这种方式只能聚合先于自己启动的微服务。所以，需要被聚合的微服务在自己启动时，主动去8080端口的服务注册自己。打开8081和8082端口对应的服务，修改配置：</p>
<pre><code class="language-java">package com.zlyx.easytest.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.zlyx.easyswagger.config.ApiConfiguration;

@Configuration
public class SwaggerConfiguration {

	@Bean
	public ApiConfiguration configApi() {

   }
}
</code></pre>
<p>有了这个配置，8081端口和8082端口的服务就会在自己启动时主动注册到8080端口的服务。</p>
<p>喜欢的话，到码云 https://gitee.com/xiaoyudeguang/easy-swagger 加个star呗</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[各种浏览器都试过以后，我非常慎重的回归了360...]]></title>
        <id>https://xiaoyudeguang.github.io/post/ge-chong-liu-lan-qi-du-shi-guo-yi-hou-wo-fei-chang-shen-chong-de-hui-gui-liao-360/</id>
        <link href="https://xiaoyudeguang.github.io/post/ge-chong-liu-lan-qi-du-shi-guo-yi-hou-wo-fei-chang-shen-chong-de-hui-gui-liao-360/">
        </link>
        <updated>2020-02-11T08:38:09.000Z</updated>
        <summary type="html"><![CDATA[<p>从大学时期，一直在用360安全浏览器。多次被人诟病太low。作为一个程序员，360安全浏览器的确不是一个好的选择。但是，因为一直用的360出的360手机，手机端也是360浏览器，和PC端的数据可以进行同步的，就一直没舍得换。这次因为工作的需要，不得不试着换一个浏览器用。</p>
]]></summary>
        <content type="html"><![CDATA[<p>从大学时期，一直在用360安全浏览器。多次被人诟病太low。作为一个程序员，360安全浏览器的确不是一个好的选择。但是，因为一直用的360出的360手机，手机端也是360浏览器，和PC端的数据可以进行同步的，就一直没舍得换。这次因为工作的需要，不得不试着换一个浏览器用。</p>
<!-- more -->
<p>第一选择当然是传闻中非常牛逼的谷歌啊。一通操作猛如虎，结果不能登录。长期以来的习惯，不能云端登录备份的软件不是好软件，尤其是我还有一个攒了好多年的收藏夹库需要一直备份着。谷歌提供了登录功能，但是需要翻墙。好不容易翻墙了，注册谷歌账号吧，结果手机号不能用。果断弃了。</p>
<p>第二选择是火狐浏览器。怎么说呢，不好不坏，没啥特色。先放着，再试试别的。</p>
<p>第三选择是微软的edge。考虑是系统自带，万一好用呢。然鹅，试过以后就不想用了。操作功能啥功能都没有，和其他浏览器相比简直就是简陋的毛坯房。同时，一样的网速，edge的速度简直是龟速。360浏览器已经打开一个网站操作好一会了，edge终于加载出来了。不愧是微软官方出品的浏览器， 就是牛，和ie一样牛，啥也不说了，清空数据退出，over。`</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[乔迁之喜]]></title>
        <id>https://xiaoyudeguang.github.io/post/da-sa-da-sa/</id>
        <link href="https://xiaoyudeguang.github.io/post/da-sa-da-sa/">
        </link>
        <updated>2020-02-11T07:11:50.000Z</updated>
        <summary type="html"><![CDATA[<pre><code>      我的个人博客之旅开始啦！
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<pre><code>      我的个人博客之旅开始啦！
</code></pre>
<!-- more -->
]]></content>
    </entry>
</feed>